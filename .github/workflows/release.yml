name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag to release (e.g., v1.0.0)'
        required: true
        type: string

env:
  APP_NAME: Pindrop
  SCHEME: Pindrop
  CONFIGURATION: Release
  SPARKLE_VERSION: "2.6.4"

jobs:
  build:
    runs-on: macos-26
    permissions:
      contents: write
      actions: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Dependencies
        run: |
          # Install create-dmg for DMG creation
          brew install create-dmg

          # Download Sparkle tools directly (same as justfile)
          echo "ðŸ“¦ Downloading Sparkle ${SPARKLE_VERSION} tools..."
          curl -L -o /tmp/Sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
          mkdir -p /tmp/sparkle-extract
          tar -xf /tmp/Sparkle.tar.xz -C /tmp/sparkle-extract
          
          # Copy tools to a known location
          mkdir -p bin
          cp /tmp/sparkle-extract/bin/generate_appcast bin/
          cp /tmp/sparkle-extract/bin/sign_update bin/
          chmod +x bin/generate_appcast bin/sign_update
          
          # Cleanup
          rm -rf /tmp/Sparkle.tar.xz /tmp/sparkle-extract
          
          echo "âœ… Sparkle tools installed to bin/"
          ls -la bin/

      - name: Get Version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.tag }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          # Remove 'v' prefix for the app version
          APP_VERSION="${VERSION#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION (app: $APP_VERSION)"

      - name: Resolve Target Commit
        id: target
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ steps.version.outputs.version }}"
            TARGET_SHA=$(git rev-list -n 1 "$TAG")
          else
            TARGET_SHA="${{ github.sha }}"
          fi

          if [ -z "$TARGET_SHA" ]; then
            echo "âŒ Failed to resolve target commit SHA"
            exit 1
          fi

          echo "sha=$TARGET_SHA" >> $GITHUB_OUTPUT
          echo "Target commit: $TARGET_SHA"

      - name: Wait for CI to complete
        id: wait_for_ci
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TARGET_SHA="${{ steps.target.outputs.sha }}"
          echo "Waiting for CI run on commit: $TARGET_SHA"

          for attempt in {1..60}; do
            RUN_JSON=$(gh run list \
              --workflow ci.yml \
              --commit "$TARGET_SHA" \
              --json databaseId,status,conclusion,url \
              --limit 1)

            RUN_ID=$(echo "$RUN_JSON" | jq -r '.[0].databaseId // empty')
            STATUS=$(echo "$RUN_JSON" | jq -r '.[0].status // empty')
            CONCLUSION=$(echo "$RUN_JSON" | jq -r '.[0].conclusion // empty')
            URL=$(echo "$RUN_JSON" | jq -r '.[0].url // empty')

            if [ -z "$RUN_ID" ]; then
              echo "No CI run found yet for this commit (attempt $attempt/60)."
              sleep 10
              continue
            fi

            echo "CI run $RUN_ID status=$STATUS conclusion=$CONCLUSION"

            if [ "$STATUS" = "completed" ]; then
              if [ "$CONCLUSION" = "success" ]; then
                echo "âœ… CI succeeded: $URL"
                echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
                exit 0
              fi

              echo "âŒ CI failed with conclusion: $CONCLUSION"
              echo "Run URL: $URL"
              exit 1
            fi

            sleep 10
          done

          echo "âŒ Timed out waiting for CI to finish"
          exit 1

      - name: Download CI Artifact
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TARGET_SHA="${{ steps.target.outputs.sha }}"
          ARTIFACT_NAME="${{ env.APP_NAME }}-${TARGET_SHA}"
          mkdir -p dist

          gh run download "${{ steps.wait_for_ci.outputs.run_id }}" \
            --name "$ARTIFACT_NAME" \
            --dir dist

          ARTIFACT_PATH="dist/${{ env.APP_NAME }}-${TARGET_SHA}.zip"
          if [ ! -f "$ARTIFACT_PATH" ]; then
            echo "âŒ Expected artifact not found: $ARTIFACT_PATH"
            ls -la dist
            exit 1
          fi

          echo "artifact_path=$ARTIFACT_PATH" >> $GITHUB_ENV
          echo "âœ… Downloaded CI artifact: $ARTIFACT_PATH"

      - name: Extract App from Artifact
        run: |
          EXTRACT_DIR="dist/extracted"
          mkdir -p "$EXTRACT_DIR"

          ditto -x -k "${{ env.artifact_path }}" "$EXTRACT_DIR"

          APP_PATH=$(find "$EXTRACT_DIR" -name "${{ env.APP_NAME }}.app" -type d | head -1)
          if [ -z "$APP_PATH" ]; then
            echo "âŒ App bundle not found after extraction"
            find "$EXTRACT_DIR" -maxdepth 4 -type d
            exit 1
          fi

          echo "app_path=$APP_PATH" >> $GITHUB_ENV
          echo "âœ… App extracted at: $APP_PATH"

      - name: Create DMG
        id: dmg
        run: |
          APP_PATH="${{ env.app_path }}"
          VERSION="${{ steps.version.outputs.app_version }}"
          DMG_NAME="${{ env.APP_NAME }}-${VERSION}.dmg"
          DMG_PATH="dist/${DMG_NAME}"

          mkdir -p dist

          # Create the DMG (matches scripts/create-dmg-self-signed.sh)
          create-dmg \
            --volname "${{ env.APP_NAME }}" \
            --window-pos 200 120 \
            --window-size 600 400 \
            --icon-size 100 \
            --app-drop-link 450 185 \
            --icon "${{ env.APP_NAME }}.app" 150 185 \
            "${DMG_PATH}" \
            "${APP_PATH}"

          echo "DMG created at: ${DMG_PATH}"
          echo "dmg_path=${DMG_PATH}" >> $GITHUB_ENV
          echo "dmg_name=${DMG_NAME}" >> $GITHUB_ENV

      - name: Sign DMG with EdDSA
        env:
          SPARKLE_EDDSA_PRIVATE_KEY: ${{ secrets.SPARKLE_EDDSA_PRIVATE_KEY }}
        run: |
          if [ -z "$SPARKLE_EDDSA_PRIVATE_KEY" ]; then
            echo "âš ï¸  Warning: SPARKLE_EDDSA_PRIVATE_KEY secret is not set"
            echo "   Skipping EdDSA signing - updates will not be verifiable!"
            echo "   To enable signing, add your EdDSA private key to GitHub Secrets"
            echo "dmg_signature=" >> $GITHUB_ENV
            exit 0
          fi

          DMG_PATH="${{ env.dmg_path }}"

          # Sign the DMG using Sparkle's sign_update tool
          # The tool outputs: sparkle:edSignature="..." length="..."
          # We extract just the signature value
          SIGN_OUTPUT=$(echo "$SPARKLE_EDDSA_PRIVATE_KEY" | ./bin/sign_update "$DMG_PATH" -f -)
          SIGNATURE=$(echo "$SIGN_OUTPUT" | sed -n 's/.*sparkle:edSignature="\([^"]*\)".*/\1/p')

          echo "âœ… DMG signed with EdDSA"
          echo "   Signature: ${SIGNATURE:0:20}..."
          echo "dmg_signature=${SIGNATURE}" >> $GITHUB_ENV

      - name: Generate Appcast
        run: |
          VERSION="${{ steps.version.outputs.app_version }}"
          FULL_VERSION="${{ steps.version.outputs.version }}"
          DMG_NAME="${{ env.dmg_name }}"
          DMG_PATH="${{ env.dmg_path }}"
          SIGNATURE="${{ env.dmg_signature }}"

          # Get DMG size
          DMG_SIZE=$(stat -f%z "$DMG_PATH")

          # Get current date in RFC 2822 format
          PUB_DATE=$(date -R)

          # Build signature attribute if present
          if [ -n "$SIGNATURE" ]; then
            SIG_ATTR="sparkle:edSignature=\"${SIGNATURE}\""
          else
            SIG_ATTR=""
          fi

          # Create the appcast.xml
          cat > dist/appcast.xml << APPCAST_EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>${{ env.APP_NAME }} Changelog</title>
              <link>https://github.com/${{ github.repository }}/releases</link>
              <description>Most recent changes with links to updates.</description>
              <language>en</language>
              <item>
                <title>Version ${VERSION}</title>
                <pubDate>${PUB_DATE}</pubDate>
                <enclosure
                  url="https://github.com/${{ github.repository }}/releases/download/${FULL_VERSION}/${DMG_NAME}"
                  sparkle:version="${VERSION}"
                  sparkle:shortVersionString="${VERSION}"
                  ${SIG_ATTR}
                  length="${DMG_SIZE}"
                  type="application/octet-stream"
                />
                <sparkle:minimumSystemVersion>14.0</sparkle:minimumSystemVersion>
              </item>
            </channel>
          </rss>
          APPCAST_EOF

          echo "âœ… Appcast generated at: dist/appcast.xml"
          cat dist/appcast.xml

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: "${{ env.APP_NAME }} ${{ steps.version.outputs.app_version }}"
          draft: true
          prerelease: false
          make_latest: true
          files: |
            ${{ env.dmg_path }}
            dist/appcast.xml
          body: |
            ## ${{ env.APP_NAME }} ${{ steps.version.outputs.app_version }}
            
            ### Installation
            1. Download `${{ env.dmg_name }}`
            2. Open the DMG and drag ${{ env.APP_NAME }} to your Applications folder
            3. Launch from Applications
            
            ### First Launch (Gatekeeper)
            Since this is a self-signed build:
            1. Right-click the app and select Open
            2. If blocked: System Settings â†’ Privacy & Security â†’ Open Anyway
            
            ### Notes
            - macOS 14.0+ required
            - Apple Silicon optimized (Universal binary)
            - Self-signed (no Apple Developer account)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        run: |
          SIGNED="No (secret not configured)"
          if [ -n "${{ env.dmg_signature }}" ]; then
            SIGNED="Yes"
          fi
          
          echo "## Release Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **DMG:** ${{ env.dmg_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **EdDSA Signed:** ${SIGNED}" >> $GITHUB_STEP_SUMMARY
          echo "- **Release:** Draft created (requires manual publishing)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the draft release on GitHub" >> $GITHUB_STEP_SUMMARY
          echo "2. Add release notes" >> $GITHUB_STEP_SUMMARY
          echo "3. Publish the release when ready" >> $GITHUB_STEP_SUMMARY
          echo "4. After publishing, commit the appcast.xml to the main branch" >> $GITHUB_STEP_SUMMARY
